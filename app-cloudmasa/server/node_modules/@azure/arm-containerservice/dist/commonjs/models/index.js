"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.KnownNodeProvisioningMode = exports.KnownIstioIngressGatewayMode = exports.KnownServiceMeshMode = exports.KnownPublicNetworkAccess = exports.KnownNginxIngressControllerType = exports.KnownKeyVaultNetworkAccessTypes = exports.KnownExpander = exports.KnownNodeOSUpgradeChannel = exports.KnownUpgradeChannel = exports.KnownIpFamily = exports.KnownBackendPoolType = exports.KnownLoadBalancerSku = exports.KnownOutboundType = exports.KnownAdvancedNetworkPolicies = exports.KnownNetworkDataplane = exports.KnownNetworkMode = exports.KnownNetworkPolicy = exports.KnownNetworkPluginMode = exports.KnownNetworkPlugin = exports.KnownRestrictionLevel = exports.KnownManagedClusterPodIdentityProvisioningState = exports.KnownLicenseType = exports.KnownLocalDNSServeStale = exports.KnownLocalDNSForwardPolicy = exports.KnownLocalDNSForwardDestination = exports.KnownLocalDNSProtocol = exports.KnownLocalDNSQueryLogging = exports.KnownLocalDNSState = exports.KnownLocalDNSMode = exports.KnownGPUDriver = exports.KnownAgentPoolSSHAccess = exports.KnownProtocol = exports.KnownGPUInstanceProfile = exports.KnownScaleSetEvictionPolicy = exports.KnownScaleSetPriority = exports.KnownUndrainableNodeBehavior = exports.KnownAgentPoolMode = exports.KnownAgentPoolType = exports.KnownScaleDownMode = exports.KnownOssku = exports.KnownOSType = exports.KnownPodIPAllocationMode = exports.KnownWorkloadRuntime = exports.KnownKubeletDiskType = exports.KnownOSDiskType = exports.KnownCode = exports.KnownExtendedLocationTypes = exports.KnownManagedClusterSKUTier = exports.KnownManagedClusterSKUName = exports.KnownKubernetesSupportPlan = void 0;
exports.KnownTrustedAccessRoleBindingProvisioningState = exports.KnownSnapshotType = exports.KnownConnectionStatus = exports.KnownPrivateEndpointConnectionProvisioningState = exports.KnownDeletePolicy = exports.KnownAdoptionPolicy = exports.KnownPolicyRule = exports.KnownNamespaceProvisioningState = exports.KnownType = exports.KnownWeekDay = exports.KnownFormat = exports.KnownCreatedByType = exports.KnownArtifactSource = exports.KnownNodeProvisioningDefaultNodePools = void 0;
/** Known values of {@link KubernetesSupportPlan} that the service accepts. */
var KnownKubernetesSupportPlan;
(function (KnownKubernetesSupportPlan) {
    /** Support for the version is the same as for the open source Kubernetes offering. Official Kubernetes open source community support versions for 1 year after release. */
    KnownKubernetesSupportPlan["KubernetesOfficial"] = "KubernetesOfficial";
    /** Support for the version extended past the KubernetesOfficial support of 1 year. AKS continues to patch CVEs for another 1 year, for a total of 2 years of support. */
    KnownKubernetesSupportPlan["AKSLongTermSupport"] = "AKSLongTermSupport";
})(KnownKubernetesSupportPlan || (exports.KnownKubernetesSupportPlan = KnownKubernetesSupportPlan = {}));
/** Known values of {@link ManagedClusterSKUName} that the service accepts. */
var KnownManagedClusterSKUName;
(function (KnownManagedClusterSKUName) {
    /** Base option for the AKS control plane. */
    KnownManagedClusterSKUName["Base"] = "Base";
    /** Automatic clusters are optimized to run most production workloads with configuration that follows AKS best practices and recommendations for cluster and workload setup, scalability, and security. For more details about Automatic clusters see aka.ms\/aks\/automatic. */
    KnownManagedClusterSKUName["Automatic"] = "Automatic";
})(KnownManagedClusterSKUName || (exports.KnownManagedClusterSKUName = KnownManagedClusterSKUName = {}));
/** Known values of {@link ManagedClusterSKUTier} that the service accepts. */
var KnownManagedClusterSKUTier;
(function (KnownManagedClusterSKUTier) {
    /** Cluster has premium capabilities in addition to all of the capabilities included in 'Standard'. Premium enables selection of LongTermSupport (aka.ms\/aks\/lts) for certain Kubernetes versions. */
    KnownManagedClusterSKUTier["Premium"] = "Premium";
    /** Recommended for mission-critical and production workloads. Includes Kubernetes control plane autoscaling, workload-intensive testing, and up to 5,000 nodes per cluster. Guarantees 99.95% availability of the Kubernetes API server endpoint for clusters that use Availability Zones and 99.9% of availability for clusters that don't use Availability Zones. */
    KnownManagedClusterSKUTier["Standard"] = "Standard";
    /** The cluster management is free, but charged for VM, storage, and networking usage. Best for experimenting, learning, simple testing, or workloads with fewer than 10 nodes. Not recommended for production use cases. */
    KnownManagedClusterSKUTier["Free"] = "Free";
})(KnownManagedClusterSKUTier || (exports.KnownManagedClusterSKUTier = KnownManagedClusterSKUTier = {}));
/** Known values of {@link ExtendedLocationTypes} that the service accepts. */
var KnownExtendedLocationTypes;
(function (KnownExtendedLocationTypes) {
    /** EdgeZone */
    KnownExtendedLocationTypes["EdgeZone"] = "EdgeZone";
})(KnownExtendedLocationTypes || (exports.KnownExtendedLocationTypes = KnownExtendedLocationTypes = {}));
/** Known values of {@link Code} that the service accepts. */
var KnownCode;
(function (KnownCode) {
    /** The cluster is running. */
    KnownCode["Running"] = "Running";
    /** The cluster is stopped. */
    KnownCode["Stopped"] = "Stopped";
})(KnownCode || (exports.KnownCode = KnownCode = {}));
/** Known values of {@link OSDiskType} that the service accepts. */
var KnownOSDiskType;
(function (KnownOSDiskType) {
    /** Azure replicates the operating system disk for a virtual machine to Azure storage to avoid data loss should the VM need to be relocated to another host. Since containers aren't designed to have local state persisted, this behavior offers limited value while providing some drawbacks, including slower node provisioning and higher read\/write latency. */
    KnownOSDiskType["Managed"] = "Managed";
    /** Ephemeral OS disks are stored only on the host machine, just like a temporary disk. This provides lower read\/write latency, along with faster node scaling and cluster upgrades. */
    KnownOSDiskType["Ephemeral"] = "Ephemeral";
})(KnownOSDiskType || (exports.KnownOSDiskType = KnownOSDiskType = {}));
/** Known values of {@link KubeletDiskType} that the service accepts. */
var KnownKubeletDiskType;
(function (KnownKubeletDiskType) {
    /** Kubelet will use the OS disk for its data. */
    KnownKubeletDiskType["OS"] = "OS";
    /** Kubelet will use the temporary disk for its data. */
    KnownKubeletDiskType["Temporary"] = "Temporary";
})(KnownKubeletDiskType || (exports.KnownKubeletDiskType = KnownKubeletDiskType = {}));
/** Known values of {@link WorkloadRuntime} that the service accepts. */
var KnownWorkloadRuntime;
(function (KnownWorkloadRuntime) {
    /** Nodes will use Kubelet to run standard OCI container workloads. */
    KnownWorkloadRuntime["OCIContainer"] = "OCIContainer";
    /** Nodes will use Krustlet to run WASM workloads using the WASI provider (Preview). */
    KnownWorkloadRuntime["WasmWasi"] = "WasmWasi";
    /** Nodes can use (Kata + Cloud Hypervisor + Hyper-V) to enable Nested VM-based pods. Due to the use Hyper-V, AKS node OS itself is a nested VM (the root OS) of Hyper-V. Thus it can only be used with VM series that support Nested Virtualization such as Dv3 series. */
    KnownWorkloadRuntime["KataVmIsolation"] = "KataVmIsolation";
})(KnownWorkloadRuntime || (exports.KnownWorkloadRuntime = KnownWorkloadRuntime = {}));
/** Known values of {@link PodIPAllocationMode} that the service accepts. */
var KnownPodIPAllocationMode;
(function (KnownPodIPAllocationMode) {
    /** Each node gets allocated with a non-contiguous list of IP addresses assignable to pods. This is better for maximizing a small to medium subnet of size \/16 or smaller. The Azure CNI cluster with dynamic IP allocation defaults to this mode if the customer does not explicitly specify a podIPAllocationMode */
    KnownPodIPAllocationMode["DynamicIndividual"] = "DynamicIndividual";
    /** Each node is statically allocated CIDR block(s) of size \/28 = 16 IPs per block to satisfy the maxPods per node. Number of CIDR blocks >= (maxPods \/ 16). The block, rather than a single IP, counts against the Azure Vnet Private IP limit of 65K. Therefore block mode is suitable for running larger workloads with more than the current limit of 65K pods in a cluster. This mode is better suited to scale with larger subnets of \/15 or bigger */
    KnownPodIPAllocationMode["StaticBlock"] = "StaticBlock";
})(KnownPodIPAllocationMode || (exports.KnownPodIPAllocationMode = KnownPodIPAllocationMode = {}));
/** Known values of {@link OSType} that the service accepts. */
var KnownOSType;
(function (KnownOSType) {
    /** Use Linux. */
    KnownOSType["Linux"] = "Linux";
    /** Use Windows. */
    KnownOSType["Windows"] = "Windows";
})(KnownOSType || (exports.KnownOSType = KnownOSType = {}));
/** Known values of {@link Ossku} that the service accepts. */
var KnownOssku;
(function (KnownOssku) {
    /** Use Ubuntu as the OS for node images. */
    KnownOssku["Ubuntu"] = "Ubuntu";
    /** Use AzureLinux as the OS for node images. Azure Linux is a container-optimized Linux distro built by Microsoft, visit https:\//aka.ms\/azurelinux for more information. */
    KnownOssku["AzureLinux"] = "AzureLinux";
    /** Use AzureLinux3 as the OS for node images. Azure Linux is a container-optimized Linux distro built by Microsoft, visit https:\//aka.ms\/azurelinux for more information. For limitations, visit https:\//aka.ms\/aks\/node-images. For OS migration guidance, see https:\//aka.ms\/aks\/upgrade-os-version. */
    KnownOssku["AzureLinux3"] = "AzureLinux3";
    /** Deprecated OSSKU. Microsoft recommends that new deployments choose 'AzureLinux' instead. */
    KnownOssku["CBLMariner"] = "CBLMariner";
    /** Use Windows2019 as the OS for node images. Unsupported for system node pools. Windows2019 only supports Windows2019 containers; it cannot run Windows2022 containers and vice versa. */
    KnownOssku["Windows2019"] = "Windows2019";
    /** Use Windows2022 as the OS for node images. Unsupported for system node pools. Windows2022 only supports Windows2022 containers; it cannot run Windows2019 containers and vice versa. */
    KnownOssku["Windows2022"] = "Windows2022";
    /** Use Ubuntu2204 as the OS for node images, however, Ubuntu 22.04 may not be supported for all nodepools. For limitations and supported kubernetes versions, see https:\//aka.ms\/aks\/supported-ubuntu-versions */
    KnownOssku["Ubuntu2204"] = "Ubuntu2204";
    /** Use Ubuntu2404 as the OS for node images, however, Ubuntu 24.04 may not be supported for all nodepools. For limitations and supported kubernetes versions, see https:\//aka.ms\/aks\/supported-ubuntu-versions */
    KnownOssku["Ubuntu2404"] = "Ubuntu2404";
})(KnownOssku || (exports.KnownOssku = KnownOssku = {}));
/** Known values of {@link ScaleDownMode} that the service accepts. */
var KnownScaleDownMode;
(function (KnownScaleDownMode) {
    /** Create new instances during scale up and remove instances during scale down. */
    KnownScaleDownMode["Delete"] = "Delete";
    /** Attempt to start deallocated instances (if they exist) during scale up and deallocate instances during scale down. */
    KnownScaleDownMode["Deallocate"] = "Deallocate";
})(KnownScaleDownMode || (exports.KnownScaleDownMode = KnownScaleDownMode = {}));
/** Known values of {@link AgentPoolType} that the service accepts. */
var KnownAgentPoolType;
(function (KnownAgentPoolType) {
    /** Create an Agent Pool backed by a Virtual Machine Scale Set. */
    KnownAgentPoolType["VirtualMachineScaleSets"] = "VirtualMachineScaleSets";
    /** Use of this is strongly discouraged. */
    KnownAgentPoolType["AvailabilitySet"] = "AvailabilitySet";
    /** Create an Agent Pool backed by a Single Instance VM orchestration mode. */
    KnownAgentPoolType["VirtualMachines"] = "VirtualMachines";
})(KnownAgentPoolType || (exports.KnownAgentPoolType = KnownAgentPoolType = {}));
/** Known values of {@link AgentPoolMode} that the service accepts. */
var KnownAgentPoolMode;
(function (KnownAgentPoolMode) {
    /** System agent pools are primarily for hosting critical system pods such as CoreDNS and metrics-server. System agent pools osType must be Linux. System agent pools VM SKU must have at least 2vCPUs and 4GB of memory. */
    KnownAgentPoolMode["System"] = "System";
    /** User agent pools are primarily for hosting your application pods. */
    KnownAgentPoolMode["User"] = "User";
    /** Gateway agent pools are dedicated to providing static egress IPs to pods. For more details, see https:\//aka.ms\/aks\/static-egress-gateway. */
    KnownAgentPoolMode["Gateway"] = "Gateway";
})(KnownAgentPoolMode || (exports.KnownAgentPoolMode = KnownAgentPoolMode = {}));
/** Known values of {@link UndrainableNodeBehavior} that the service accepts. */
var KnownUndrainableNodeBehavior;
(function (KnownUndrainableNodeBehavior) {
    /** AKS will cordon the blocked nodes and replace them with surge nodes during upgrade. The blocked nodes will be cordoned and replaced by surge nodes. The blocked nodes will have label 'kubernetes.azure.com\/upgrade-status:Quarantined'. A surge node will be retained for each blocked node. A best-effort attempt will be made to delete all other surge nodes. If there are enough surge nodes to replace blocked nodes, then the upgrade operation and the managed cluster will be in failed state. Otherwise, the upgrade operation and the managed cluster will be in canceled state. */
    KnownUndrainableNodeBehavior["Cordon"] = "Cordon";
    /** AKS will mark the blocked nodes schedulable, but the blocked nodes are not upgraded. A best-effort attempt will be made to delete all surge nodes. The upgrade operation and the managed cluster will be in failed state if there are any blocked nodes. */
    KnownUndrainableNodeBehavior["Schedule"] = "Schedule";
})(KnownUndrainableNodeBehavior || (exports.KnownUndrainableNodeBehavior = KnownUndrainableNodeBehavior = {}));
/** Known values of {@link ScaleSetPriority} that the service accepts. */
var KnownScaleSetPriority;
(function (KnownScaleSetPriority) {
    /** Spot priority VMs will be used. There is no SLA for spot nodes. See [spot on AKS](https:\//docs.microsoft.com\/azure\/aks\/spot-node-pool) for more information. */
    KnownScaleSetPriority["Spot"] = "Spot";
    /** Regular VMs will be used. */
    KnownScaleSetPriority["Regular"] = "Regular";
})(KnownScaleSetPriority || (exports.KnownScaleSetPriority = KnownScaleSetPriority = {}));
/** Known values of {@link ScaleSetEvictionPolicy} that the service accepts. */
var KnownScaleSetEvictionPolicy;
(function (KnownScaleSetEvictionPolicy) {
    /** Nodes in the underlying Scale Set of the node pool are deleted when they're evicted. */
    KnownScaleSetEvictionPolicy["Delete"] = "Delete";
    /** Nodes in the underlying Scale Set of the node pool are set to the stopped-deallocated state upon eviction. Nodes in the stopped-deallocated state count against your compute quota and can cause issues with cluster scaling or upgrading. */
    KnownScaleSetEvictionPolicy["Deallocate"] = "Deallocate";
})(KnownScaleSetEvictionPolicy || (exports.KnownScaleSetEvictionPolicy = KnownScaleSetEvictionPolicy = {}));
/** Known values of {@link GPUInstanceProfile} that the service accepts. */
var KnownGPUInstanceProfile;
(function (KnownGPUInstanceProfile) {
    /** MIG1G */
    KnownGPUInstanceProfile["MIG1G"] = "MIG1g";
    /** MIG2G */
    KnownGPUInstanceProfile["MIG2G"] = "MIG2g";
    /** MIG3G */
    KnownGPUInstanceProfile["MIG3G"] = "MIG3g";
    /** MIG4G */
    KnownGPUInstanceProfile["MIG4G"] = "MIG4g";
    /** MIG7G */
    KnownGPUInstanceProfile["MIG7G"] = "MIG7g";
})(KnownGPUInstanceProfile || (exports.KnownGPUInstanceProfile = KnownGPUInstanceProfile = {}));
/** Known values of {@link Protocol} that the service accepts. */
var KnownProtocol;
(function (KnownProtocol) {
    /** TCP protocol. */
    KnownProtocol["TCP"] = "TCP";
    /** UDP protocol. */
    KnownProtocol["UDP"] = "UDP";
})(KnownProtocol || (exports.KnownProtocol = KnownProtocol = {}));
/** Known values of {@link AgentPoolSSHAccess} that the service accepts. */
var KnownAgentPoolSSHAccess;
(function (KnownAgentPoolSSHAccess) {
    /** Can SSH onto the node as a local user using private key. */
    KnownAgentPoolSSHAccess["LocalUser"] = "LocalUser";
    /** SSH service will be turned off on the node. */
    KnownAgentPoolSSHAccess["Disabled"] = "Disabled";
})(KnownAgentPoolSSHAccess || (exports.KnownAgentPoolSSHAccess = KnownAgentPoolSSHAccess = {}));
/** Known values of {@link GPUDriver} that the service accepts. */
var KnownGPUDriver;
(function (KnownGPUDriver) {
    /** Install driver. */
    KnownGPUDriver["Install"] = "Install";
    /** Skip driver install. */
    KnownGPUDriver["None"] = "None";
})(KnownGPUDriver || (exports.KnownGPUDriver = KnownGPUDriver = {}));
/** Known values of {@link LocalDNSMode} that the service accepts. */
var KnownLocalDNSMode;
(function (KnownLocalDNSMode) {
    /** If the current orchestrator version supports this feature, prefer enabling localDNS. */
    KnownLocalDNSMode["Preferred"] = "Preferred";
    /** Enable localDNS. */
    KnownLocalDNSMode["Required"] = "Required";
    /** Disable localDNS. */
    KnownLocalDNSMode["Disabled"] = "Disabled";
})(KnownLocalDNSMode || (exports.KnownLocalDNSMode = KnownLocalDNSMode = {}));
/** Known values of {@link LocalDNSState} that the service accepts. */
var KnownLocalDNSState;
(function (KnownLocalDNSState) {
    /** localDNS is enabled. */
    KnownLocalDNSState["Enabled"] = "Enabled";
    /** localDNS is disabled. */
    KnownLocalDNSState["Disabled"] = "Disabled";
})(KnownLocalDNSState || (exports.KnownLocalDNSState = KnownLocalDNSState = {}));
/** Known values of {@link LocalDNSQueryLogging} that the service accepts. */
var KnownLocalDNSQueryLogging;
(function (KnownLocalDNSQueryLogging) {
    /** Enables error logging in localDNS. See [errors plugin](https:\//coredns.io\/plugins\/errors) for more information. */
    KnownLocalDNSQueryLogging["Error"] = "Error";
    /** Enables query logging in localDNS. See [log plugin](https:\//coredns.io\/plugins\/log) for more information. */
    KnownLocalDNSQueryLogging["Log"] = "Log";
})(KnownLocalDNSQueryLogging || (exports.KnownLocalDNSQueryLogging = KnownLocalDNSQueryLogging = {}));
/** Known values of {@link LocalDNSProtocol} that the service accepts. */
var KnownLocalDNSProtocol;
(function (KnownLocalDNSProtocol) {
    /** Prefer UDP protocol for connections from localDNS to upstream DNS server. */
    KnownLocalDNSProtocol["PreferUDP"] = "PreferUDP";
    /** Enforce TCP protocol for connections from localDNS to upstream DNS server. */
    KnownLocalDNSProtocol["ForceTCP"] = "ForceTCP";
})(KnownLocalDNSProtocol || (exports.KnownLocalDNSProtocol = KnownLocalDNSProtocol = {}));
/** Known values of {@link LocalDNSForwardDestination} that the service accepts. */
var KnownLocalDNSForwardDestination;
(function (KnownLocalDNSForwardDestination) {
    /** Forward DNS queries from localDNS to cluster CoreDNS. */
    KnownLocalDNSForwardDestination["ClusterCoreDNS"] = "ClusterCoreDNS";
    /** Forward DNS queries from localDNS to DNS server configured in the VNET. A VNET can have multiple DNS servers configured. */
    KnownLocalDNSForwardDestination["VnetDNS"] = "VnetDNS";
})(KnownLocalDNSForwardDestination || (exports.KnownLocalDNSForwardDestination = KnownLocalDNSForwardDestination = {}));
/** Known values of {@link LocalDNSForwardPolicy} that the service accepts. */
var KnownLocalDNSForwardPolicy;
(function (KnownLocalDNSForwardPolicy) {
    /** Implements sequential upstream DNS server selection. See [forward plugin](https:\//coredns.io\/plugins\/forward) for more information. */
    KnownLocalDNSForwardPolicy["Sequential"] = "Sequential";
    /** Implements round robin upstream DNS server selection. See [forward plugin](https:\//coredns.io\/plugins\/forward) for more information. */
    KnownLocalDNSForwardPolicy["RoundRobin"] = "RoundRobin";
    /** Implements random upstream DNS server selection. See [forward plugin](https:\//coredns.io\/plugins\/forward) for more information. */
    KnownLocalDNSForwardPolicy["Random"] = "Random";
})(KnownLocalDNSForwardPolicy || (exports.KnownLocalDNSForwardPolicy = KnownLocalDNSForwardPolicy = {}));
/** Known values of {@link LocalDNSServeStale} that the service accepts. */
var KnownLocalDNSServeStale;
(function (KnownLocalDNSServeStale) {
    /** Serve stale data with verification. First verify that an entry is still unavailable from the source before sending the expired entry to the client. See [cache plugin](https:\//coredns.io\/plugins\/cache) for more information. */
    KnownLocalDNSServeStale["Verify"] = "Verify";
    /** Serve stale data immediately. Send the expired entry to the client before checking to see if the entry is available from the source. See [cache plugin](https:\//coredns.io\/plugins\/cache) for more information. */
    KnownLocalDNSServeStale["Immediate"] = "Immediate";
    /** Disable serving stale data. */
    KnownLocalDNSServeStale["Disable"] = "Disable";
})(KnownLocalDNSServeStale || (exports.KnownLocalDNSServeStale = KnownLocalDNSServeStale = {}));
/** Known values of {@link LicenseType} that the service accepts. */
var KnownLicenseType;
(function (KnownLicenseType) {
    /** No additional licensing is applied. */
    KnownLicenseType["None"] = "None";
    /** Enables Azure Hybrid User Benefits for Windows VMs. */
    KnownLicenseType["WindowsServer"] = "Windows_Server";
})(KnownLicenseType || (exports.KnownLicenseType = KnownLicenseType = {}));
/** Known values of {@link ManagedClusterPodIdentityProvisioningState} that the service accepts. */
var KnownManagedClusterPodIdentityProvisioningState;
(function (KnownManagedClusterPodIdentityProvisioningState) {
    /** Assigned */
    KnownManagedClusterPodIdentityProvisioningState["Assigned"] = "Assigned";
    /** Canceled */
    KnownManagedClusterPodIdentityProvisioningState["Canceled"] = "Canceled";
    /** Deleting */
    KnownManagedClusterPodIdentityProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownManagedClusterPodIdentityProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownManagedClusterPodIdentityProvisioningState["Succeeded"] = "Succeeded";
    /** Updating */
    KnownManagedClusterPodIdentityProvisioningState["Updating"] = "Updating";
})(KnownManagedClusterPodIdentityProvisioningState || (exports.KnownManagedClusterPodIdentityProvisioningState = KnownManagedClusterPodIdentityProvisioningState = {}));
/** Known values of {@link RestrictionLevel} that the service accepts. */
var KnownRestrictionLevel;
(function (KnownRestrictionLevel) {
    /** All RBAC permissions are allowed on the managed node resource group */
    KnownRestrictionLevel["Unrestricted"] = "Unrestricted";
    /** Only *\/read RBAC permissions allowed on the managed node resource group */
    KnownRestrictionLevel["ReadOnly"] = "ReadOnly";
})(KnownRestrictionLevel || (exports.KnownRestrictionLevel = KnownRestrictionLevel = {}));
/** Known values of {@link NetworkPlugin} that the service accepts. */
var KnownNetworkPlugin;
(function (KnownNetworkPlugin) {
    /** Use the Azure CNI network plugin. See [Azure CNI (advanced) networking](https:\//docs.microsoft.com\/azure\/aks\/concepts-network#azure-cni-advanced-networking) for more information. */
    KnownNetworkPlugin["Azure"] = "azure";
    /** Use the Kubenet network plugin. See [Kubenet (basic) networking](https:\//docs.microsoft.com\/azure\/aks\/concepts-network#kubenet-basic-networking) for more information. */
    KnownNetworkPlugin["Kubenet"] = "kubenet";
    /** No CNI plugin is pre-installed. See [BYO CNI](https:\//docs.microsoft.com\/en-us\/azure\/aks\/use-byo-cni) for more information. */
    KnownNetworkPlugin["None"] = "none";
})(KnownNetworkPlugin || (exports.KnownNetworkPlugin = KnownNetworkPlugin = {}));
/** Known values of {@link NetworkPluginMode} that the service accepts. */
var KnownNetworkPluginMode;
(function (KnownNetworkPluginMode) {
    /** Used with networkPlugin=azure, pods are given IPs from the PodCIDR address space but use Azure Routing Domains rather than Kubenet's method of route tables. For more information visit https:\//aka.ms\/aks\/azure-cni-overlay. */
    KnownNetworkPluginMode["Overlay"] = "overlay";
})(KnownNetworkPluginMode || (exports.KnownNetworkPluginMode = KnownNetworkPluginMode = {}));
/** Known values of {@link NetworkPolicy} that the service accepts. */
var KnownNetworkPolicy;
(function (KnownNetworkPolicy) {
    /** Network policies will not be enforced. This is the default value when NetworkPolicy is not specified. */
    KnownNetworkPolicy["None"] = "none";
    /** Use Calico network policies. See [differences between Azure and Calico policies](https:\//docs.microsoft.com\/azure\/aks\/use-network-policies#differences-between-azure-and-calico-policies-and-their-capabilities) for more information. */
    KnownNetworkPolicy["Calico"] = "calico";
    /** Use Azure network policies. See [differences between Azure and Calico policies](https:\//docs.microsoft.com\/azure\/aks\/use-network-policies#differences-between-azure-and-calico-policies-and-their-capabilities) for more information. */
    KnownNetworkPolicy["Azure"] = "azure";
    /** Use Cilium to enforce network policies. This requires networkDataplane to be 'cilium'. */
    KnownNetworkPolicy["Cilium"] = "cilium";
})(KnownNetworkPolicy || (exports.KnownNetworkPolicy = KnownNetworkPolicy = {}));
/** Known values of {@link NetworkMode} that the service accepts. */
var KnownNetworkMode;
(function (KnownNetworkMode) {
    /** No bridge is created. Intra-VM Pod to Pod communication is through IP routes created by Azure CNI. See [Transparent Mode](https:\//docs.microsoft.com\/azure\/aks\/faq#transparent-mode) for more information. */
    KnownNetworkMode["Transparent"] = "transparent";
    /** This is no longer supported */
    KnownNetworkMode["Bridge"] = "bridge";
})(KnownNetworkMode || (exports.KnownNetworkMode = KnownNetworkMode = {}));
/** Known values of {@link NetworkDataplane} that the service accepts. */
var KnownNetworkDataplane;
(function (KnownNetworkDataplane) {
    /** Use Azure network dataplane. */
    KnownNetworkDataplane["Azure"] = "azure";
    /** Use Cilium network dataplane. See [Azure CNI Powered by Cilium](https:\//learn.microsoft.com\/azure\/aks\/azure-cni-powered-by-cilium) for more information. */
    KnownNetworkDataplane["Cilium"] = "cilium";
})(KnownNetworkDataplane || (exports.KnownNetworkDataplane = KnownNetworkDataplane = {}));
/** Known values of {@link AdvancedNetworkPolicies} that the service accepts. */
var KnownAdvancedNetworkPolicies;
(function (KnownAdvancedNetworkPolicies) {
    /** Enable Layer7 network policies (FQDN, HTTP\/S, Kafka). This option is a superset of the FQDN option. */
    KnownAdvancedNetworkPolicies["L7"] = "L7";
    /** Enable FQDN based network policies */
    KnownAdvancedNetworkPolicies["Fqdn"] = "FQDN";
    /** Disable Layer 7 network policies (FQDN, HTTP\/S, Kafka) */
    KnownAdvancedNetworkPolicies["None"] = "None";
})(KnownAdvancedNetworkPolicies || (exports.KnownAdvancedNetworkPolicies = KnownAdvancedNetworkPolicies = {}));
/** Known values of {@link OutboundType} that the service accepts. */
var KnownOutboundType;
(function (KnownOutboundType) {
    /** The load balancer is used for egress through an AKS assigned public IP. This supports Kubernetes services of type 'loadBalancer'. For more information see [outbound type loadbalancer](https:\//docs.microsoft.com\/azure\/aks\/egress-outboundtype#outbound-type-of-loadbalancer). */
    KnownOutboundType["LoadBalancer"] = "loadBalancer";
    /** Egress paths must be defined by the user. This is an advanced scenario and requires proper network configuration. For more information see [outbound type userDefinedRouting](https:\//docs.microsoft.com\/azure\/aks\/egress-outboundtype#outbound-type-of-userdefinedrouting). */
    KnownOutboundType["UserDefinedRouting"] = "userDefinedRouting";
    /** The AKS-managed NAT gateway is used for egress. */
    KnownOutboundType["ManagedNATGateway"] = "managedNATGateway";
    /** The user-assigned NAT gateway associated to the cluster subnet is used for egress. This is an advanced scenario and requires proper network configuration. */
    KnownOutboundType["UserAssignedNATGateway"] = "userAssignedNATGateway";
    /** The AKS cluster is not set with any outbound-type. All AKS nodes follows Azure VM default outbound behavior. Please refer to https:\//azure.microsoft.com\/en-us\/updates\/default-outbound-access-for-vms-in-azure-will-be-retired-transition-to-a-new-method-of-internet-access\/ */
    KnownOutboundType["None"] = "none";
})(KnownOutboundType || (exports.KnownOutboundType = KnownOutboundType = {}));
/** Known values of {@link LoadBalancerSku} that the service accepts. */
var KnownLoadBalancerSku;
(function (KnownLoadBalancerSku) {
    /** Use a a standard Load Balancer. This is the recommended Load Balancer SKU. For more information about on working with the load balancer in the managed cluster, see the [standard Load Balancer](https:\//docs.microsoft.com\/azure\/aks\/load-balancer-standard) article. */
    KnownLoadBalancerSku["Standard"] = "standard";
    /** Use a basic Load Balancer with limited functionality. */
    KnownLoadBalancerSku["Basic"] = "basic";
})(KnownLoadBalancerSku || (exports.KnownLoadBalancerSku = KnownLoadBalancerSku = {}));
/** Known values of {@link BackendPoolType} that the service accepts. */
var KnownBackendPoolType;
(function (KnownBackendPoolType) {
    /** The type of the managed inbound Load Balancer BackendPool. https:\//cloud-provider-azure.sigs.k8s.io\/topics\/loadbalancer\/#configure-load-balancer-backend. */
    KnownBackendPoolType["NodeIPConfiguration"] = "NodeIPConfiguration";
    /** The type of the managed inbound Load Balancer BackendPool. https:\//cloud-provider-azure.sigs.k8s.io\/topics\/loadbalancer\/#configure-load-balancer-backend. */
    KnownBackendPoolType["NodeIP"] = "NodeIP";
})(KnownBackendPoolType || (exports.KnownBackendPoolType = KnownBackendPoolType = {}));
/** Known values of {@link IpFamily} that the service accepts. */
var KnownIpFamily;
(function (KnownIpFamily) {
    /** IPv4 */
    KnownIpFamily["IPv4"] = "IPv4";
    /** IPv6 */
    KnownIpFamily["IPv6"] = "IPv6";
})(KnownIpFamily || (exports.KnownIpFamily = KnownIpFamily = {}));
/** Known values of {@link UpgradeChannel} that the service accepts. */
var KnownUpgradeChannel;
(function (KnownUpgradeChannel) {
    /** Automatically upgrade the cluster to the latest supported patch release on the latest supported minor version. In cases where the cluster is at a version of Kubernetes that is at an N-2 minor version where N is the latest supported minor version, the cluster first upgrades to the latest supported patch version on N-1 minor version. For example, if a cluster is running version 1.17.7 and versions 1.17.9, 1.18.4, 1.18.6, and 1.19.1 are available, your cluster first is upgraded to 1.18.6, then is upgraded to 1.19.1. */
    KnownUpgradeChannel["Rapid"] = "rapid";
    /** Automatically upgrade the cluster to the latest supported patch release on minor version N-1, where N is the latest supported minor version. For example, if a cluster is running version 1.17.7 and versions 1.17.9, 1.18.4, 1.18.6, and 1.19.1 are available, your cluster is upgraded to 1.18.6. */
    KnownUpgradeChannel["Stable"] = "stable";
    /** Automatically upgrade the cluster to the latest supported patch version when it becomes available while keeping the minor version the same. For example, if a cluster is running version 1.17.7 and versions 1.17.9, 1.18.4, 1.18.6, and 1.19.1 are available, your cluster is upgraded to 1.17.9. */
    KnownUpgradeChannel["Patch"] = "patch";
    /** Automatically upgrade the node image to the latest version available. Consider using nodeOSUpgradeChannel instead as that allows you to configure node OS patching separate from Kubernetes version patching */
    KnownUpgradeChannel["NodeImage"] = "node-image";
    /** Disables auto-upgrades and keeps the cluster at its current version of Kubernetes. */
    KnownUpgradeChannel["None"] = "none";
})(KnownUpgradeChannel || (exports.KnownUpgradeChannel = KnownUpgradeChannel = {}));
/** Known values of {@link NodeOSUpgradeChannel} that the service accepts. */
var KnownNodeOSUpgradeChannel;
(function (KnownNodeOSUpgradeChannel) {
    /** No attempt to update your machines OS will be made either by OS or by rolling VHDs. This means you are responsible for your security updates */
    KnownNodeOSUpgradeChannel["None"] = "None";
    /** OS updates will be applied automatically through the OS built-in patching infrastructure. Newly scaled in machines will be unpatched initially and will be patched at some point by the OS's infrastructure. Behavior of this option depends on the OS in question. Ubuntu and Mariner apply security patches through unattended upgrade roughly once a day around 06:00 UTC. Windows does not apply security patches automatically and so for them this option is equivalent to None till further notice */
    KnownNodeOSUpgradeChannel["Unmanaged"] = "Unmanaged";
    /** AKS will update the nodes with a newly patched VHD containing security fixes and bugfixes on a weekly cadence. With the VHD update machines will be rolling reimaged to that VHD following maintenance windows and surge settings. No extra VHD cost is incurred when choosing this option as AKS hosts the images. */
    KnownNodeOSUpgradeChannel["NodeImage"] = "NodeImage";
    /** AKS downloads and updates the nodes with tested security updates. These updates honor the maintenance window settings and produce a new VHD that is used on new nodes. On some occasions it's not possible to apply the updates in place, in such cases the existing nodes will also be re-imaged to the newly produced VHD in order to apply the changes. This option incurs an extra cost of hosting the new Security Patch VHDs in your resource group for just in time consumption. */
    KnownNodeOSUpgradeChannel["SecurityPatch"] = "SecurityPatch";
})(KnownNodeOSUpgradeChannel || (exports.KnownNodeOSUpgradeChannel = KnownNodeOSUpgradeChannel = {}));
/** Known values of {@link Expander} that the service accepts. */
var KnownExpander;
(function (KnownExpander) {
    /** Selects the node group that will have the least idle CPU (if tied, unused memory) after scale-up. This is useful when you have different classes of nodes, for example, high CPU or high memory nodes, and only want to expand those when there are pending pods that need a lot of those resources. */
    KnownExpander["LeastWaste"] = "least-waste";
    /** Selects the node group that would be able to schedule the most pods when scaling up. This is useful when you are using nodeSelector to make sure certain pods land on certain nodes. Note that this won't cause the autoscaler to select bigger nodes vs. smaller, as it can add multiple smaller nodes at once. */
    KnownExpander["MostPods"] = "most-pods";
    /** Selects the node group that has the highest priority assigned by the user. It's configuration is described in more details [here](https:\//github.com\/kubernetes\/autoscaler\/blob\/master\/cluster-autoscaler\/expander\/priority\/readme.md). */
    KnownExpander["Priority"] = "priority";
    /** Used when you don't have a particular need for the node groups to scale differently. */
    KnownExpander["Random"] = "random";
})(KnownExpander || (exports.KnownExpander = KnownExpander = {}));
/** Known values of {@link KeyVaultNetworkAccessTypes} that the service accepts. */
var KnownKeyVaultNetworkAccessTypes;
(function (KnownKeyVaultNetworkAccessTypes) {
    /** Public */
    KnownKeyVaultNetworkAccessTypes["Public"] = "Public";
    /** Private */
    KnownKeyVaultNetworkAccessTypes["Private"] = "Private";
})(KnownKeyVaultNetworkAccessTypes || (exports.KnownKeyVaultNetworkAccessTypes = KnownKeyVaultNetworkAccessTypes = {}));
/** Known values of {@link NginxIngressControllerType} that the service accepts. */
var KnownNginxIngressControllerType;
(function (KnownNginxIngressControllerType) {
    /** The default NginxIngressController will be created. Users can edit the default NginxIngressController Custom Resource to configure load balancer annotations. */
    KnownNginxIngressControllerType["AnnotationControlled"] = "AnnotationControlled";
    /** The default NginxIngressController will be created and the operator will provision an external loadbalancer with it. Any annotation to make the default loadbalancer internal will be overwritten. */
    KnownNginxIngressControllerType["External"] = "External";
    /** The default NginxIngressController will be created and the operator will provision an internal loadbalancer with it. Any annotation to make the default loadbalancer external will be overwritten. */
    KnownNginxIngressControllerType["Internal"] = "Internal";
    /** The default Ingress Controller will not be created. It will not be deleted by the system if it exists. Users should delete the default NginxIngressController Custom Resource manually if desired. */
    KnownNginxIngressControllerType["None"] = "None";
})(KnownNginxIngressControllerType || (exports.KnownNginxIngressControllerType = KnownNginxIngressControllerType = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
var KnownPublicNetworkAccess;
(function (KnownPublicNetworkAccess) {
    /** Enabled */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = KnownPublicNetworkAccess = {}));
/** Known values of {@link ServiceMeshMode} that the service accepts. */
var KnownServiceMeshMode;
(function (KnownServiceMeshMode) {
    /** Istio deployed as an AKS addon. */
    KnownServiceMeshMode["Istio"] = "Istio";
    /** Mesh is disabled. */
    KnownServiceMeshMode["Disabled"] = "Disabled";
})(KnownServiceMeshMode || (exports.KnownServiceMeshMode = KnownServiceMeshMode = {}));
/** Known values of {@link IstioIngressGatewayMode} that the service accepts. */
var KnownIstioIngressGatewayMode;
(function (KnownIstioIngressGatewayMode) {
    /** The ingress gateway is assigned a public IP address and is publicly accessible. */
    KnownIstioIngressGatewayMode["External"] = "External";
    /** The ingress gateway is assigned an internal IP address and cannot is accessed publicly. */
    KnownIstioIngressGatewayMode["Internal"] = "Internal";
})(KnownIstioIngressGatewayMode || (exports.KnownIstioIngressGatewayMode = KnownIstioIngressGatewayMode = {}));
/** Known values of {@link NodeProvisioningMode} that the service accepts. */
var KnownNodeProvisioningMode;
(function (KnownNodeProvisioningMode) {
    /** Nodes are provisioned manually by the user */
    KnownNodeProvisioningMode["Manual"] = "Manual";
    /** Nodes are provisioned automatically by AKS using Karpenter (See aka.ms\/aks\/nap for more details). Fixed size Node Pools can still be created, but autoscaling Node Pools cannot be. (See aka.ms\/aks\/nap for more details). */
    KnownNodeProvisioningMode["Auto"] = "Auto";
})(KnownNodeProvisioningMode || (exports.KnownNodeProvisioningMode = KnownNodeProvisioningMode = {}));
/** Known values of {@link NodeProvisioningDefaultNodePools} that the service accepts. */
var KnownNodeProvisioningDefaultNodePools;
(function (KnownNodeProvisioningDefaultNodePools) {
    /** No Karpenter NodePools are provisioned automatically. Automatic scaling will not happen unless the user creates one or more NodePool CRD instances. */
    KnownNodeProvisioningDefaultNodePools["None"] = "None";
    /** A standard set of Karpenter NodePools are provisioned */
    KnownNodeProvisioningDefaultNodePools["Auto"] = "Auto";
})(KnownNodeProvisioningDefaultNodePools || (exports.KnownNodeProvisioningDefaultNodePools = KnownNodeProvisioningDefaultNodePools = {}));
/** Known values of {@link ArtifactSource} that the service accepts. */
var KnownArtifactSource;
(function (KnownArtifactSource) {
    /** pull images from Azure Container Registry with cache */
    KnownArtifactSource["Cache"] = "Cache";
    /** pull images from Microsoft Artifact Registry */
    KnownArtifactSource["Direct"] = "Direct";
})(KnownArtifactSource || (exports.KnownArtifactSource = KnownArtifactSource = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
var KnownCreatedByType;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(KnownCreatedByType || (exports.KnownCreatedByType = KnownCreatedByType = {}));
/** Known values of {@link Format} that the service accepts. */
var KnownFormat;
(function (KnownFormat) {
    /** Return azure auth-provider kubeconfig. This format is deprecated in v1.22 and will be fully removed in v1.26. See: https:\//aka.ms\/k8s\/changes-1-26. */
    KnownFormat["Azure"] = "azure";
    /** Return exec format kubeconfig. This format requires kubelogin binary in the path. */
    KnownFormat["Exec"] = "exec";
})(KnownFormat || (exports.KnownFormat = KnownFormat = {}));
/** Known values of {@link WeekDay} that the service accepts. */
var KnownWeekDay;
(function (KnownWeekDay) {
    /** Sunday */
    KnownWeekDay["Sunday"] = "Sunday";
    /** Monday */
    KnownWeekDay["Monday"] = "Monday";
    /** Tuesday */
    KnownWeekDay["Tuesday"] = "Tuesday";
    /** Wednesday */
    KnownWeekDay["Wednesday"] = "Wednesday";
    /** Thursday */
    KnownWeekDay["Thursday"] = "Thursday";
    /** Friday */
    KnownWeekDay["Friday"] = "Friday";
    /** Saturday */
    KnownWeekDay["Saturday"] = "Saturday";
})(KnownWeekDay || (exports.KnownWeekDay = KnownWeekDay = {}));
/** Known values of {@link Type} that the service accepts. */
var KnownType;
(function (KnownType) {
    /** First week of the month. */
    KnownType["First"] = "First";
    /** Second week of the month. */
    KnownType["Second"] = "Second";
    /** Third week of the month. */
    KnownType["Third"] = "Third";
    /** Fourth week of the month. */
    KnownType["Fourth"] = "Fourth";
    /** Last week of the month. */
    KnownType["Last"] = "Last";
})(KnownType || (exports.KnownType = KnownType = {}));
/** Known values of {@link NamespaceProvisioningState} that the service accepts. */
var KnownNamespaceProvisioningState;
(function (KnownNamespaceProvisioningState) {
    /** Updating */
    KnownNamespaceProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownNamespaceProvisioningState["Deleting"] = "Deleting";
    /** Creating */
    KnownNamespaceProvisioningState["Creating"] = "Creating";
    /** Succeeded */
    KnownNamespaceProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownNamespaceProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownNamespaceProvisioningState["Canceled"] = "Canceled";
})(KnownNamespaceProvisioningState || (exports.KnownNamespaceProvisioningState = KnownNamespaceProvisioningState = {}));
/** Known values of {@link PolicyRule} that the service accepts. */
var KnownPolicyRule;
(function (KnownPolicyRule) {
    /** Deny all network traffic. */
    KnownPolicyRule["DenyAll"] = "DenyAll";
    /** Allow all network traffic. */
    KnownPolicyRule["AllowAll"] = "AllowAll";
    /** Allow traffic within the same namespace. */
    KnownPolicyRule["AllowSameNamespace"] = "AllowSameNamespace";
})(KnownPolicyRule || (exports.KnownPolicyRule = KnownPolicyRule = {}));
/** Known values of {@link AdoptionPolicy} that the service accepts. */
var KnownAdoptionPolicy;
(function (KnownAdoptionPolicy) {
    /** If the namespace already exists in Kubernetes, attempts to create that same namespace in ARM will fail. */
    KnownAdoptionPolicy["Never"] = "Never";
    /** Take over the existing namespace to be managed by ARM, if there is no difference. */
    KnownAdoptionPolicy["IfIdentical"] = "IfIdentical";
    /** Always take over the existing namespace to be managed by ARM, some fields might be overwritten. */
    KnownAdoptionPolicy["Always"] = "Always";
})(KnownAdoptionPolicy || (exports.KnownAdoptionPolicy = KnownAdoptionPolicy = {}));
/** Known values of {@link DeletePolicy} that the service accepts. */
var KnownDeletePolicy;
(function (KnownDeletePolicy) {
    /** Only delete the ARM resource, keep the Kubernetes namespace. Also delete the ManagedByARM label. */
    KnownDeletePolicy["Keep"] = "Keep";
    /** Delete both the ARM resource and the Kubernetes namespace together. */
    KnownDeletePolicy["Delete"] = "Delete";
})(KnownDeletePolicy || (exports.KnownDeletePolicy = KnownDeletePolicy = {}));
/** Known values of {@link PrivateEndpointConnectionProvisioningState} that the service accepts. */
var KnownPrivateEndpointConnectionProvisioningState;
(function (KnownPrivateEndpointConnectionProvisioningState) {
    /** Canceled */
    KnownPrivateEndpointConnectionProvisioningState["Canceled"] = "Canceled";
    /** Creating */
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
})(KnownPrivateEndpointConnectionProvisioningState || (exports.KnownPrivateEndpointConnectionProvisioningState = KnownPrivateEndpointConnectionProvisioningState = {}));
/** Known values of {@link ConnectionStatus} that the service accepts. */
var KnownConnectionStatus;
(function (KnownConnectionStatus) {
    /** Pending */
    KnownConnectionStatus["Pending"] = "Pending";
    /** Approved */
    KnownConnectionStatus["Approved"] = "Approved";
    /** Rejected */
    KnownConnectionStatus["Rejected"] = "Rejected";
    /** Disconnected */
    KnownConnectionStatus["Disconnected"] = "Disconnected";
})(KnownConnectionStatus || (exports.KnownConnectionStatus = KnownConnectionStatus = {}));
/** Known values of {@link SnapshotType} that the service accepts. */
var KnownSnapshotType;
(function (KnownSnapshotType) {
    /** The snapshot is a snapshot of a node pool. */
    KnownSnapshotType["NodePool"] = "NodePool";
})(KnownSnapshotType || (exports.KnownSnapshotType = KnownSnapshotType = {}));
/** Known values of {@link TrustedAccessRoleBindingProvisioningState} that the service accepts. */
var KnownTrustedAccessRoleBindingProvisioningState;
(function (KnownTrustedAccessRoleBindingProvisioningState) {
    /** Canceled */
    KnownTrustedAccessRoleBindingProvisioningState["Canceled"] = "Canceled";
    /** Deleting */
    KnownTrustedAccessRoleBindingProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownTrustedAccessRoleBindingProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownTrustedAccessRoleBindingProvisioningState["Succeeded"] = "Succeeded";
    /** Updating */
    KnownTrustedAccessRoleBindingProvisioningState["Updating"] = "Updating";
})(KnownTrustedAccessRoleBindingProvisioningState || (exports.KnownTrustedAccessRoleBindingProvisioningState = KnownTrustedAccessRoleBindingProvisioningState = {}));
//# sourceMappingURL=index.js.map